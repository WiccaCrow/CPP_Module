C ++ - Модуль 05

Повторение и исключения

Описание: Этот документ содержит тему для Модуля 05 модулей C ++. 
Версия: 9
_____________________________________________________________________
СОДЕРЖАНИЕ

I   Общие правила ................................................   2
II  Упражнение 00: Мамочка, когда вырасту, хочу быть бюрократом!..   4
III Упражнение 01: Собирайтесь, личинки! .........................   6
IV  Упражнение 02: Нет, вам нужна форма 28B, а не 28C ............   7
V   Упражнение 03: По крайней мере, это лучше, чем приготовление   
                                 кофе ............................   9

_____________________________________________________________________
Глава I
Основные правила

Для модулей C ++ вы будете использовать и изучать только C ++ 98.
Цель состоит в том, чтобы вы изучили основы объектно-ориентированного языка 
программирования.
Мы знаем, что современный C ++ сильно отличается во многих аспектах, поэтому, 
если вы хотите стать опытным разработчиком C ++, позже вам понадобится 
современный стандартный C ++. Это будет отправной точкой вашего пути к C ++, 
и вам решать, как продвигаться дальше после 42 Common Core!

• Любая функция, реализованная в заголовке (кроме шаблонов), и любой 
  незащищенный заголовок означает 0 для упражнения.

• Каждый вывод переходит в стандартный вывод и будет заканчиваться новой 
  строкой, если не указано иное.

• Введенные имена файлов должны следовать до буквы, так же как имена классов, 
  имена функций и имена методов.

• Помните: вы сейчас кодите на C ++, а не на C. Следовательно:

      ◦ Следующие функции ЗАПРЕЩЕНЫ, и их использование будет наказано 0, 
        без вопросов: *	alloc, * printf и free.

      ◦ Вам разрешено использовать все, что есть в стандартной библиотеке. 
        ОДНАКО, было бы разумно попытаться использовать версии C ++ функций, 
        к которым вы привыкли в C, вместо того, чтобы просто придерживаться 
        того, что вы знаете, в конце концов, это новый язык. 
        И НЕТ, вам не разрешается использовать STL до тех пор, пока вы не должны 
        (то есть до модуля 08). Это означает, что до тех пор нет 
        векторов / списков / карт / и т. Д. ... 
        или чего-либо, что требует включения <algorithm>.

• Фактически, использование любой явно запрещенной функции или механизма будет 
  наказываться 0 без вопросов.

• Также обратите внимание, что если не указано иное, ключевые слова C ++ 
  «using namespace» и «friend» запрещены. Их использование будет наказано -42, 
  без вопросов.

• Файлы, связанные с классом, всегда будут ClassName.hpp и ClassName.cpp, 
  если не указано иное.

• Каталоги сдачи: ex00 /, ex01 /,. . . , exn /.

• Вы должны внимательно прочитать примеры. Они могут содержать требования, 
  которые не очевидны в описании упражнения.

• Поскольку вам разрешено использовать инструменты C ++, о которых вы узнали с 
  самого начала, вам не разрешается использовать какие-либо внешние библиотеки. 
  И прежде чем вы спросите, это также означает отсутствие C ++ 11 и его 
  производных, Boost или чего-либо еще.

• От вас могут потребовать сдать большое количество занятий. Это может 
  показаться утомительным, если вы не умеете писать скрипт в своем любимом 
  текстовом редакторе.

• Прочтите каждое упражнение ПОЛНОСТЬЮ перед тем, как приступить к нему! 
  Сделай это.

• Используемый компилятор - c ++.

• Ваш код должен быть скомпилирован со следующими флагами: 
  -Wall -Wextra -Werror.

• Каждое из ваших включений должно иметь возможность включаться независимо от 
  других. Включаемые элементы должны содержать все остальные включения, от 
  которых они зависят.

• Если вам интересно, в C ++ стиль кодирования не применяется. 
  Вы можете использовать любой понравившийся стиль, без ограничений. 
  Но помните, что код, который ваш коллега-оценщик не может прочитать, - 
  это код, который они не могут оценить.

• Важный момент: вы НЕ будете оцениваться программой, если это явно не указано 
  в теме. Таким образом, вам предоставляется определенная свобода в выборе 
  выполнения упражнений. Однако помните об ограничениях каждого упражнения и 
  НЕ ленитесь, вы пропустите МНОГО из того, что они могут предложить.

• Не проблема иметь какие-то посторонние файлы в том, что вы передаете, 
  вы можете разделить свой код на большее количество файлов, чем то, что от 
  вас требуется. Не стесняйтесь, если результат не оценивается программой.

• Даже если тема упражнения короткая, стоит потратить на нее некоторое 
  время, чтобы убедиться, что вы понимаете, чего от вас ждут, и что вы 
  сделали это наилучшим образом.

• Один, Тор! Используй свой мозг!!!
_____________________________________________________________________
Глава II.
Упражнение 00: Мамочка, когда вырасту, хочу быть бюрократом!
Mommy, when I grow up, I want to be a bureaucrat!

_________________________________________________________
|           Упражнение: 00                              |
|_______________________________________________________|
|        Мамочка, когда вырасту, хочу быть бюрократом!  |
|_______________________________________________________|
|   Каталог сдачи: ex00/                                |
|_______________________________________________________|
|   Файлы для передачи: Makefile, main.cpp,             |
|                Bureaucrat.hpp Bureaucrat.cpp          |
|_______________________________________________________|
|   Запрещенные функции: Нет                            |
|_______________________________________________________|

Обратите внимание, что классы исключений не обязательно должны иметь 
ортодоксальную каноническую форму. 
Каждый другой класс должен быть написан таким образом.

Сегодня мы собираемся создать искусственный кошмар офисов, коридоров, 
форм и очередей. Звучит смешно? Нет? Очень плохо.

Во-первых, мы начнем с мельчайшего винтика огромной бюрократической машины: 
Bureaucrat.

У него должно быть постоянное имя (name) и оценка (grade) в диапазоне 
от 1 (максимально возможное) до 150 (минимально возможное). 
Любая попытка создать Bureaucrat с недопустимой оценкой (grade) должна 
вызывать исключение, которое будет либо 
Bureaucrat::GradeTooHighException 
, либо 
Bureaucrat::GradeTooLowException
.

Вы предоставите геттеры (getters, добытчик) для обоих этих атрибутов 
(getName и getGrade) и две функции для увеличения или уменьшения оценки. 
Обе эти функции вызовут те же исключения, что и раньше, если оценка станет 
слишком высокой или слишком низкой. Помните, что оценка 
1 - самая высокая, 150 - самая низкая, 
поэтому повышение оценки на 3 дает вам оценку 2 ...

Выбрасываемые вами исключения должны быть перехвачены блоком, например:
try
{
	/* do some stuff with bureaucrats */
}
catch (std::exception & e) 
{
	/* handle exception */
}

Вы предоставите перегрузку оператора << для ostream, который выводит что-то 
вроде 
<name>, bureaucrat grade <grade>.

Конечно, вы предоставите основную функцию, чтобы доказать, что вы все это 
сделали хорошо.

_____________________________________________________________________
Глава III.

Упражнение 01: Form up, maggots!

_________________________________________________________
|           Упражнение: 01                              |
|_______________________________________________________|
|           Собирайтесь, личинки!                       |
|_______________________________________________________|
|   Каталог сдачи: ex01/                                |
|_______________________________________________________|
|   Файлы для передачи: : То же, что и раньше +         |
|                         Form.cpp Form.hpp             |
|_______________________________________________________|
|   Запрещенные функции: нет                            |
|_______________________________________________________|

Теперь, когда у нас есть бюрократы, лучше дайте им что-то, 
чтобы занять свое временя. Что может быть лучше, чем 
стопка заполненных бланков?

Создайте Form class. 
У него есть имя (name), логическое значение 
(a boolean indicating whether it is signed), указывающее, 
подписан ли он (в начале это не так), 
оценка, необходимая для его подписания, 
и оценка, необходимая для его выполнения (grade to execute). 
Имя и оценки постоянны, и все эти атрибуты являются частными 
(не защищенными). 
Оценки подчиняются тем же ограничениям, что и в Бюрократе, 
и исключения будут выдаваться, если любое из них выходит 
за пределы, 
Form :: GradeTooHighException и 
Form :: GradeTooLowException.

Как и раньше, создайте геттеры для всех атрибутов и перегрузку 
оператора << в ostream, который полностью описывает состояние формы.

Вы также добавите функцию beSigned, которая принимает бюрократа 
и подписывает форму, если оценка бюрократа достаточно высока. 
Всегда помните, что оценка 1 лучше, чем оценка 2. 
Если оценка слишком низкая, генерируйте исключение 
Form :: GradeTooLowException.

Также добавьте в Бюрократ функцию signForm. 
Если подписание прошло успешно, он напечатает что-то вроде 
«<бюрократ> подписывает <форма>», 
иначе он напечатает что-то вроде 
«<бюрократ> не может подписать <форму>, потому что <причина>».

Добавьте все, что нужно для проверки, в свой main.

















_____________________________________________________________________
Глава IV.

Упражнение 02:  Нет, вам нужна форма 28B, а не 28C ...

_________________________________________________________________
|                        Упражнение: 02                         |
|_______________________________________________________________|
|              Нет, вам нужна форма 28B, а не 28C ...           |
|_______________________________________________________________|
|    Каталог сдачи: ex02/                                       |
|_______________________________________________________________|
|   Файлы для передачи:   Как и раньше +                        |
|           ShrubberyCreationForm.[hpp,cpp]                     |
|           RobotomyRequestForm.[hpp,cpp]                       |
|           PresidentialPardonForm.[hpp,cpp]                    |
|_______________________________________________________________|
|   Запрещенные функции: нет                                    |
|_______________________________________________________________|

Теперь, когда у вас есть базовые формы, вы создадите несколько 
форм, которые действительно что-то делают.

Создайте несколько конкретных форм:

• ShrubberyCreationForm 
    (обязательные оценки: sign 145, exec 137). 
    Действие: Создает файл с именем <target>_shrubbery 
    и записывает в него деревья ASCII в текущем каталоге.

• RobotomyRequestForm 
    (обязательные оценки: sign 72, exec 45). 
    Действие: издает какие-то дурацкие звуки и сообщает нам, 
    что <цель> была успешно роботизирована в 50% случаев. 
    В противном случае сообщает нам, что это сбой.

• PresidentialPardonForm 
    (обязательные оценки: знак 25, класс 5). 
    Действие: Сообщает нам, что <цель> помилована Зафодом Библброксом.

Все они должны будут принимать в своем конструкторе только один 
параметр, который будет представлять цель формы. 
Например, «дом», если вы хотите посадить кустарник у себя дома. 
Помните, что атрибуты формы должны оставаться private и 
принадлежать базовому классу.
Remember the form’s attributes need to remain private, 
and in the base class

Теперь вам нужно добавить метод 
execute(Bureaucrat const & executor) const
в базовую форму и реализовать метод, выполняющий действие формы во всех 
конкретных формах. 

Вы должны убедиться, что форма подписана и что бюрократ, пытающийся выполнить 
форму, имеет достаточно высокую оценку, иначе вы создадите соответствующее 
исключение.

Независимо от того, хотите ли вы выполнить эти проверки в каждом конкретном 
классе или выполнить регистрацию в базовом классе, 
тогда вызов другого метода для выполнения действия зависит от вас, 
но один способ красивее другого. 

В любом случае, базовая форма должна быть абстрактным классом. 
Завершите это, добавив в bureaucrat функцию anexecuteForm (Form const & form). 
Он должен попытаться выполнить форму, и в случае успеха вывести что-то вроде 
<бюрократ> выполняет <форму>. Если нет, напечатайте явное сообщение об ошибке. 
Добавьте все, что вам нужно, чтобы убедиться, что все работает.
_____________________________________________________________________
Глава V 
Упражнение 03: At least this beats coffee-making

_________________________________________________________________________
|                        Упражнение: 03                                 |
|_______________________________________________________________________|
|          По крайней мере, это лучше, чем приготовление кофе           |
|_______________________________________________________________________|
|   Каталог сдачи: ex03/                                                |
|_______________________________________________________________________|
|   Файлы для передачи: : Как и раньше + Intern.hpp Intern.cpp          |
|                                                                       |
|_______________________________________________________________________|
|   Запрещенные функции: нет                                            |
|_______________________________________________________________________|

Поскольку заполнение форм - это достаточно утомительно, было бы жестоко 
просить наших чиновников писать их самостоятельно. 
Нет, это сделает стажер.

Вы собираетесь создать класс Intern. 
У стажера нет ни имени, ни разряда, ни каких-либо определяющих характеристик, 
мы заботимся только о том, чтобы он выполнял свою работу.

У стажера есть одна важная вещь - функция makeForm.
Эта функция принимает две строки, первая из которых представляет имя формы, 
а вторая - цель для формы.

Он вернет в качестве указателя на форму указатель на любой конкретный класс 
формы, представленный первым параметром, 
инициализированный вторым параметром.

На стандартный вывод будет выведено что-то вроде 
"Intern creates <form>". 
Если он использует худший метод, например ветвления 
if / elseif / elseif / else, 
или другие уродливые вещи, подобные этому, 
он не будет принят во время оценки. 

Если запрошенная форма неизвестна, выведите явное сообщение об ошибке.
Например, при этом будет создана форма RobotomyRequestForm, нацеленная на «Бендер»:
{
    Intern  someRandomIntern;
    Form*   rrf;

    rrf = someRandomIntern.makeForm("robotomy request", "Bender");
}
Ваш main, конечно же, должен все это протестировать.