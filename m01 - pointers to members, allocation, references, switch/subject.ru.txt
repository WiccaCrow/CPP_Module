C++ - Module 01

Memory allocation, references, pointers to members, switch

Описание: Этот документ содержит тему для Модуля 01 модулей C ++.
Версия: 8
_____________________________________________________________________
СОДЕРЖАНИЕ

I    Общие правила .............................................	1
II   Упражнение 00: BraiiiiiiinnnzzzZ ..........................	4
III  Упражнение 01: Моральный мозг! ............................	5
IV   Упражнение 02: ЭТО МОЗГ ...................................	6
V    Упражнение 03: Излишнее насилие ...........................	7
VI   Упражнение 04: Сед для неудачников ........................	9
VII  Упражнение 05: Карен 2.0 ..................................	10
VIII Упражнение 06: Карен-фильтр ...............................	12


_____________________________________________________________________
Глава I
Основные правила

Для модулей C ++ вы будете использовать и изучать только C ++ 98. Цель состоит 
в том, чтобы вы изучили основы объектно-ориентированного языка программирования.
 Мы знаем, что современный C ++ сильно отличается во многих аспектах, поэтому, 
 если вы хотите стать опытным разработчиком C ++, позже вам понадобится 
 современный стандартный C ++. Это будет отправной точкой вашего пути к C ++, 
 и вам решать, как продвигаться дальше после 42 Common Core!

• Любая функция, реализованная в заголовке (кроме шаблонов), и любой 
незащищенный заголовок означает 0 для упражнения.

• Каждый вывод переходит в стандартный вывод и будет заканчиваться новой 
строкой, если не указано иное.

• Введенные имена файлов должны следовать до буквы, так же как имена классов, 
имена функций и имена методов.

• Помните: вы сейчас кодите на C ++, а не на C. Следовательно:
    ◦ Следующие функции ЗАПРЕЩЕНЫ, и их использование будет наказано 0, без 
	вопросов: * alloc, * printf и free.
    ◦ Вам разрешено использовать все, что есть в стандартной библиотеке. 
	ОДНАКО, было бы разумно попробовать использовать C ++ - ишевые версии 
	функций, к которым вы привыкли в C, вместо того, чтобы просто 
	придерживаться того, что вы знаете, в конце концов, это новый язык. И НЕТ, 
	вам не разрешается использовать STL до тех пор, пока вы не должны (то есть 
	до модуля 08). Это означает, что до тех пор 
	нет векторов / списков / карт / и т. Д. ... или чего-либо, что требует 
	включения <algorithm>.

• Фактически, использование любой явно запрещенной функции или механизма будет 
наказываться 0 без вопросов.

• Также обратите внимание, что если не указано иное, ключевые слова C ++ 
«using namespace» и «friend» запрещены. Их использование будет наказано -42, 
без вопросов.

• Файлы, связанные с классом, всегда будут ClassName.hpp и ClassName.cpp, если 
не указано иное.

• Каталоги сдачи: ex00 /, ex01 /,. . . , exn /

• Вы должны внимательно прочитать примеры. Они могут содержать требования, 
которые не очевидны в описании упражнения.

• Поскольку вам разрешено использовать инструменты C ++, о которых вы узнали 
с самого начала, вам не разрешается использовать какие-либо внешние библиотеки. 
И прежде чем вы спросите, это также означает отсутствие C ++ 11 и его 
производных, Boost или чего-либо еще.

• От вас могут потребовать сдать большое количество занятий. Это может 
показаться утомительным, если вы не умеете писать скрипт в своем любимом 
текстовом редакторе.

• Прочтите каждое упражнение ПОЛНОСТЬЮ перед тем, как приступить к нему! 
Сделай это.

• Используемый компилятор - c ++.

• Ваш код должен быть скомпилирован со следующими флагами: 
-Wall -Wextra -Werror.

• Каждое из ваших включений должно иметь возможность включаться независимо 
от других. Включаемые элементы должны содержать все остальные включения, 
от которых они зависят.

• Если вам интересно, в C ++ стиль кодирования не применяется. Вы можете 
использовать любой понравившийся стиль, без ограничений. Но помните, что 
код, который ваш коллега-оценщик не может прочитать, - это код, который 
они не могут оценить.

• Важный момент: вы НЕ будете оцениваться программой, если это явно не 
указано в теме. Таким образом, вам предоставляется определенная свобода 
в выборе выполнения упражнений. Однако помните об ограничениях каждого 
упражнения и НЕ ленитесь, вы пропустите МНОГО из того, что они могут 
предложить.

• Не проблема иметь какие-то посторонние файлы в том, что вы передаете, 
вы можете разделить свой код на большее количество файлов, чем то, что от 
вас требуется. Не стесняйтесь, пока результат не оценивается программой.

• Даже если тема упражнения короткая, стоит потратить на нее некоторое 
время, чтобы убедиться, что вы понимаете, чего от вас ждут, и что вы сделали 
это наилучшим образом.

• Один, Тор! Используй свой мозг!!!
_____________________________________________________________________
Глава II.
Упражнение 00: BraiiiiiiinnnzzzZ

_________________________________________________________
|           Упражнение: 00                              |
|_______________________________________________________|
|           BraiiiiiiinnnzzzZ                           |
|_______________________________________________________|
|   Каталог сдачи: ex00/                                |
|_______________________________________________________|
|   Файлы для передачи: Makefile, main.cpp,             |
|       Zombie.cpp, Zombie.hpp, newZombie.cpp,          |
|       randomChump.cpp                                 |
|_______________________________________________________|
|   Запрещенные функции: Нет                            |
|_______________________________________________________|

Сначала создайте класс Зомби. У зомби есть личное имя, и они могут объявлять 
(announce) о себе так:
<name> BraiiiiiiinnnzzzZ...

Да, announce(void) - это функция-член. Также добавьте отладочное сообщение 
в деструктор, включая имя Зомби.

После этого напишите функцию, которая создаст зомби, назовет его и вернет 
для использования где-нибудь еще в вашем коде. Прототип функции:
		Zombie* newZombie( std::string name );

Вам также нужно будет написать другую функцию, которая создаст зомби и 
заставит его объявить о себе.
Прототип функции:
		void randomChump( std::string name );

Теперь суть упражнения: ваши зомби должны быть уничтожены в подходящее время 
(когда они больше не нужны). Они должны быть размещены в стеке или куче, в 
зависимости от их использования: иногда уместно иметь их в стеке, в других 
случаях куча может быть лучшим выбором.

_____________________________________________________________________
Глава III.

Упражнение 01: Moar brainz!

_________________________________________________________
|           Упражнение: 01                              |
|_______________________________________________________|
|           Моральный мозг!                             |
|_______________________________________________________|
|   Каталог сдачи: ex01/                                |
|_______________________________________________________|
|   Файлы для передачи: : Makefile, main.cpp,           |
|                         Zombie.cpp, Zombie.hpp,       |
|                         ZombieHorde.cpp               |
|_______________________________________________________|
|   Запрещенные функции: Нет                            |
|_______________________________________________________|

Повторно используя класс зомби, теперь мы собираемся создать орду зомби!

Напишите функцию, которая принимает целое число N. 
При вызове она выделяет N объектов Zombie.

Он должен выделить все N объектов Zombie за одно выделение. 
Затем он должен инициализировать каждого зомби, дав каждому имя. 
Наконец, он должен вернуть указатель на первого зомби. 
Прототип функции выглядит следующим образом:
		Zombie* zombieHorde( int N, std::string name );

Отправьте main, чтобы проверить, что ваша функция zombieHorde работает 
должным образом. Вы можете сделать это, вызвав announce(void) для каждого 
из Зомби. Не забудьте удалить ВСЕХ зомби, когда они вам больше не нужны.
_____________________________________________________________________
Глава IV.

Упражнение 02: HI THIS IS BRAIN

_________________________________________________________________
|                        Упражнение: 02                         |
|_______________________________________________________________|
|                      ПРИВЕТ, ЭТО МОЗГ                         |
|_______________________________________________________________|
|    Каталог сдачи: ex02/                                       |
|_______________________________________________________________|
|    Файлы для передачи: Makefile, main.cpp                     |
|_______________________________________________________________|
|    Запрещенные функции: Нет                                   |
|_______________________________________________________________|

Составьте программу, в которой вы создадите строку, содержащую 
«HI THIS IS BRAIN».

Создайте stringPTR, который является указателем на строку; 
и stringREF, который является ссылкой на строку.

Теперь отобразите адрес в памяти строки. 
Затем отобразите адрес строки с помощью stringPTR и stringREF.
Наконец, отобразите строку с помощью указателя и, наконец, отобразите ее 
с помощью ссылки.

Все, никаких фокусов. 
Цель этого упражнения - развеять мифы о ссылках. 
Это не что-то совершенно новое, это просто еще один синтаксис того, что 
вы уже знаете: адресов. Даже есть какие-то крошечные-маленькие-мелкие детали.

_____________________________________________________________________
Глава V.
Упражнение 03: Unnecessary violence

_________________________________________________________________________
|                        Упражнение: 03                                 |
|_______________________________________________________________________|
|                    Ненужное насилие                                   |
|_______________________________________________________________________|
|   Каталог сдачи: ex03/                                                |
|_______________________________________________________________________|
|   Файлы для передачи: Makefile, main.cpp, Weapon.cpp, Weapon.hpp,     |
|                       HumanA.cpp, HumanA.hpp, HumanB.cpp, HumanB.hpp  |
|_______________________________________________________________________|
|   Запрещенные функции: Нет                                            |
|_______________________________________________________________________|

Создайте класс Weapon, который имеет тип string и метод getType, 
который возвращает константную ссылку на эту строку. 
Конечно, у него также есть setType!

Теперь создайте два класса, HumanA и HumanB, у каждого из которых есть Weapon, 
имя и функция attack (), которая отображает:
NAME attacks with his WEAPON_TYPE

HumanA и HumanB почти одинаковы; есть только две 
крошечные-маленькие-незначительные детали:
• В то время как HumanA принимает Оружие в своем конструкторе, HumanB - нет.
• HumanB не всегда может иметь оружие, но HumanA ВСЕГДА будет вооружен.

Сделайте так, чтобы следующий код в обоих тестовых случаях производил 
атаки «грубой клюшкой с шипами», ЗАТЕМ «другим типом клюшки»:

int main()
{
	{
		Weapon club = Weapon("crude spiked club");

		HumanA bob("Bob", club);
		bob.attack();
		club.setType("some other type of club");
		bob.attack();
	}
	{
		Weapon club = Weapon("crude spiked club");

		HumanB jim("Jim");
		jim.setWeapon(club);
		jim.attack();
		club.setType("some other type of club");
		jim.attack();
	}
}
В каком случае уместно хранить Оружие как указатель? А в качестве ссылки?
Почему?
Это вопросы, которые вы должны задать себе перед тем, как приступить 
к выполнению этого упражнения.
_____________________________________________________________________
Глава VI.
Упражнение 04: Sed is for losers

_________________________________________________________________________
|                       Упражнение: 04                                  |
|_______________________________________________________________________|
|                       Сед для неудачников                             |
|_______________________________________________________________________|
|   Каталог сдачи: ex04/                                                |
|_______________________________________________________________________|
|   Файлы для передачи: Makefile, main.cpp, and whatever else you need  |
|_______________________________________________________________________|
|   Запрещенные функции: Нет                                            |
|_______________________________________________________________________|

Создайте программу с именем replace, которая принимает имя файла и две строки, 
назовем их s1 и s2, которые НЕ пусты.

Он откроет файл и запишет его содержимое в FILENAME.replace после замены 
каждого вхождения s1 на s2.

Разрешены все функции-члены класса std :: string, кроме replace.
Используйте их с умом!

Конечно, вы будете обрабатывать ошибки как можно лучше.
Не используйте функции манипулирования файлами C, потому что это было бы 
жульничеством, а жульничество - плохо, понимаешь?

Вы предоставите несколько тестовых файлов, чтобы показать, что ваша программа 
работает.

_____________________________________________________________________
Глава VII.
Упражнение 05: Karen 2.0

_________________________________________________________________________
|                       Упражнение: 05                                  |
|_______________________________________________________________________|
|                       Karen 2.0                                       |
|_______________________________________________________________________|
|   Каталог сдачи: ex05/                                                |
|_______________________________________________________________________|
|   Файлы для передачи: Makefile, main.cpp, Karen.hpp, and Karen.cpp    |
|_______________________________________________________________________|
|   Запрещенные функции: Нет                                            |
|_______________________________________________________________________|

Вы знаете Карен? Все мы, не так ли? Если вы этого не сделаете, вот какие комментарии делает Карен:
• Уровень «DEBUG»: 
	сообщения на этом уровне содержат обширную контекстную информацию. 
	В основном они используются для диагностики проблем. 
	Пример: 
	«Мне нравится получать больше бекона для моего бургера 7XL-двойной-сыр-тройной-соленый-специальный-кетчуп. Мне это просто нравится!»

• Уровень «ИНФОРМАЦИЯ»: 
	эти сообщения содержат некоторую контекстную информацию, которая помогает 
	отслеживать выполнение в производственной среде. 
	Пример: 
	«Я не могу поверить, что добавление дополнительного бекона стоит больших денег. Вы не положили достаточно! Если бы вы это сделали, мне бы не пришлось просить об этом!»

• Уровень «ПРЕДУПРЕЖДЕНИЕ»: 
	предупреждающее сообщение указывает на потенциальную проблему в системе. 
	Система способна справиться с проблемой сама или в любом случае продолжить 
	ее решение. 
	Пример: 
	«Я думаю, что заслуживаю получить еще немного бекона бесплатно. Я приезжаю сюда много лет, а вы только начали здесь работать в прошлом месяце».

• Уровень «ОШИБКА»: 
	сообщение об ошибке указывает на серьезную проблему в системе. Проблема 
	обычно не устраняется и требует ручного вмешательства. 
	Пример: 
	«Это недопустимо, я хочу поговорить с менеджером сейчас».
|________________
|________________
|
|• "DEBUG" level: 
|	Messages in this level contain extensive contextual information. 
|	They are mostly used for problem diagnosis. 
|	Example: 
|	"I love to get extra bacon for my 7XL-double-cheese-triple-pickle-special-ketchup burger. I just love it!"
|• "INFO" level: 
|	These messages contain some contextual information to help trace execution 
|	in a production environment. 
|	Example: 
|	"I cannot believe adding extra bacon cost more money. You don’t put enough! If you did I would not have to ask for it!"
|• "WARNING" level: 
|	A warning message indicates a potential problem in the system. 
|	The system is able to handle the problem by itself or to proceed with this 
|	problem anyway. 
|	Example: 
|	"I think I deserve to have some extra bacon for free. I’ve been coming here for years and you just started working here last month."
|• "ERROR" level: 
|	An error message indicates a serious problem in the system. 
|	The problem is usually non-recoverable and requires manual intervention. 
|	Example: 
|	"This is unacceptable, I want to speak to the manager now."
|
|________________
|________________

Мы собираемся автоматизировать Карен, она всегда говорит одно и то же. 
Вам необходимо создать класс с именем Karen, который будет содержать 
следующие закрытые функции-члены:
• void debug( void );
• void info( void );
• void warning( void ); 
• void error( void );

Карен также должна иметь общедоступную функцию, которая вызывает частные 
функции в зависимости от уровня, переданного в качестве параметра. 
Прототип функции:
void complain( std::string level );

Цель этого упражнения - использовать указатели на функции-члены.
Это не предложение, Карен должна жаловаться, не используя лес if / elseif / else, 
она не сомневается и не думает дважды!

Отправьте основной файл, чтобы проверить, на что Карен много жалуется. 
Ничего страшного, если вы хотите использовать жалобы, которые мы приводим 
в качестве примера.

_____________________________________________________________________
Глава VIII.
Упражнение 06: Karen-filter

_________________________________________________________________________
|                       Упражнение: 06                                  |
|_______________________________________________________________________|
|                       Карен-фильтр                                    |
|_______________________________________________________________________|
|   Каталог сдачи: ex06/                                                |
|_______________________________________________________________________|
|   Файлы для передачи: Makefile, main.cpp, Karen.hpp, and Karen.cpp    |
|_______________________________________________________________________|
|   Запрещенные функции: Нет                                            |
|_______________________________________________________________________|

Мы собираемся внедрить систему фильтрации, важно ли то, что говорит Карен, 
или нет, потому что иногда мы не хотим обращать внимание на все, что говорит 
Карен.

Вы должны написать программу karenFilter, которая будет получать в качестве 
параметра уровень журнала, который вы хотите прослушивать, и отображать всю 
информацию, которая находится на этом уровне или выше. 
Например:

$> ./karenFilter "WARNING"
[ WARNING ]
I think I deserve to have some extra bacon for free.
I’ve been coming here for years and you just started working here last month.
[ ERROR ]
This is unacceptable, I want to speak to the manager now.
$> ./karenFilter "I am not sure how tired I am today..."
[ Probably complaining about insignificant problems ]

Есть много способов отфильтровать Карен, но один из лучших - ВЫКЛЮЧИТЬ ее;)
Вы должны использовать и, возможно, обнаружить в этом упражнении оператор 
switch.