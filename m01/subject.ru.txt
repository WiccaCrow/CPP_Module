C++ - Module 01

Memory allocation, references, pointers to members, switch

Описание: Этот документ содержит тему для Модуля 01 модулей C ++.
Версия: 8
_____________________________________________________________________
СОДЕРЖАНИЕ

I    Общие правила .............................................	1
II   Упражнение 00: BraiiiiiiinnnzzzZ ..........................	4
III  Упражнение 01: Моральный мозг! ............................	5
IV   Упражнение 02: ЭТО МОЗГ ...................................	6
V    Упражнение 03: Излишнее насилие ...........................	7
VI   Упражнение 04: Сед для неудачников ........................	9
VII  Упражнение 05: Карен 2.0 ..................................	10
VIII Упражнение 06: Карен-фильтр ...............................	12


_____________________________________________________________________
Глава I
Основные правила

Для модулей C ++ вы будете использовать и изучать только C ++ 98. Цель состоит 
в том, чтобы вы изучили основы объектно-ориентированного языка программирования.
 Мы знаем, что современный C ++ сильно отличается во многих аспектах, поэтому, 
 если вы хотите стать опытным разработчиком C ++, позже вам понадобится 
 современный стандартный C ++. Это будет отправной точкой вашего пути к C ++, 
 и вам решать, как продвигаться дальше после 42 Common Core!

• Любая функция, реализованная в заголовке (кроме шаблонов), и любой 
незащищенный заголовок означает 0 для упражнения.

• Каждый вывод переходит в стандартный вывод и будет заканчиваться новой 
строкой, если не указано иное.

• Введенные имена файлов должны следовать до буквы, так же как имена классов, 
имена функций и имена методов.

• Помните: вы сейчас кодите на C ++, а не на C. Следовательно:
    ◦ Следующие функции ЗАПРЕЩЕНЫ, и их использование будет наказано 0, без 
	вопросов: * alloc, * printf и free.
    ◦ Вам разрешено использовать все, что есть в стандартной библиотеке. 
	ОДНАКО, было бы разумно попробовать использовать C ++ - ишевые версии 
	функций, к которым вы привыкли в C, вместо того, чтобы просто 
	придерживаться того, что вы знаете, в конце концов, это новый язык. И НЕТ, 
	вам не разрешается использовать STL до тех пор, пока вы не должны (то есть 
	до модуля 08). Это означает, что до тех пор 
	нет векторов / списков / карт / и т. Д. ... или чего-либо, что требует 
	включения <algorithm>.

• Фактически, использование любой явно запрещенной функции или механизма будет 
наказываться 0 без вопросов.

• Также обратите внимание, что если не указано иное, ключевые слова C ++ 
«using namespace» и «friend» запрещены. Их использование будет наказано -42, 
без вопросов.

• Файлы, связанные с классом, всегда будут ClassName.hpp и ClassName.cpp, если 
не указано иное.

• Каталоги сдачи: ex00 /, ex01 /,. . . , exn /

• Вы должны внимательно прочитать примеры. Они могут содержать требования, 
которые не очевидны в описании упражнения.

• Поскольку вам разрешено использовать инструменты C ++, о которых вы узнали 
с самого начала, вам не разрешается использовать какие-либо внешние библиотеки. 
И прежде чем вы спросите, это также означает отсутствие C ++ 11 и его 
производных, Boost или чего-либо еще.

• От вас могут потребовать сдать большое количество занятий. Это может 
показаться утомительным, если вы не умеете писать скрипт в своем любимом 
текстовом редакторе.

• Прочтите каждое упражнение ПОЛНОСТЬЮ перед тем, как приступить к нему! 
Сделай это.

• Используемый компилятор - c ++.

• Ваш код должен быть скомпилирован со следующими флагами: 
-Wall -Wextra -Werror.

• Каждое из ваших включений должно иметь возможность включаться независимо 
от других. Включаемые элементы должны содержать все остальные включения, 
от которых они зависят.

• Если вам интересно, в C ++ стиль кодирования не применяется. Вы можете 
использовать любой понравившийся стиль, без ограничений. Но помните, что 
код, который ваш коллега-оценщик не может прочитать, - это код, который 
они не могут оценить.

• Важный момент: вы НЕ будете оцениваться программой, если это явно не 
указано в теме. Таким образом, вам предоставляется определенная свобода 
в выборе выполнения упражнений. Однако помните об ограничениях каждого 
упражнения и НЕ ленитесь, вы пропустите МНОГО из того, что они могут 
предложить.

• Не проблема иметь какие-то посторонние файлы в том, что вы передаете, 
вы можете разделить свой код на большее количество файлов, чем то, что от 
вас требуется. Не стесняйтесь, пока результат не оценивается программой.

• Даже если тема упражнения короткая, стоит потратить на нее некоторое 
время, чтобы убедиться, что вы понимаете, чего от вас ждут, и что вы сделали 
это наилучшим образом.

• Один, Тор! Используй свой мозг!!!
_____________________________________________________________________
Глава II.
Упражнение 00: BraiiiiiiinnnzzzZ

_________________________________________________________
|           Упражнение: 00                              |
|_______________________________________________________|
|           BraiiiiiiinnnzzzZ                           |
|_______________________________________________________|
|   Каталог сдачи: ex00/                                |
|_______________________________________________________|
|   Файлы для передачи: Makefile, main.cpp,             |
|       Zombie.cpp, Zombie.hpp, newZombie.cpp,          |
|       randomChump.cpp                                 |
|_______________________________________________________|
|   Запрещенные функции: Нет                            |
|_______________________________________________________|

Сначала создайте класс Зомби. У зомби есть личное имя, и они могут объявлять 
(announce) о себе так:
<name> BraiiiiiiinnnzzzZ...

Да, announce(void) - это функция-член. Также добавьте отладочное сообщение 
в деструктор, включая имя Зомби.

После этого напишите функцию, которая создаст зомби, назовет его и вернет 
для использования где-нибудь еще в вашем коде. Прототип функции:
		Zombie* newZombie( std::string name );

Вам также нужно будет написать другую функцию, которая создаст зомби и 
заставит его объявить о себе.
Прототип функции:
		void randomChump( std::string name );

Теперь суть упражнения: ваши зомби должны быть уничтожены в подходящее время 
(когда они больше не нужны). Они должны быть размещены в стеке или куче, в 
зависимости от их использования: иногда уместно иметь их в стеке, в других 
случаях куча может быть лучшим выбором.

_____________________________________________________________________
Глава III.

Упражнение 01: Moar brainz!

_________________________________________________________
|           Упражнение: 01                              |
|_______________________________________________________|
|           Моральный мозг!                             |
|_______________________________________________________|
|   Каталог сдачи: ex01/                                |
|_______________________________________________________|
|   Файлы для передачи: : Makefile, main.cpp,           |
|                         Zombie.cpp, Zombie.hpp,       |
|                         ZombieHorde.cpp               |
|_______________________________________________________|
|   Запрещенные функции: Нет                            |
|_______________________________________________________|

Повторно используя класс зомби, теперь мы собираемся создать орду зомби!

Напишите функцию, которая принимает целое число N. 
При вызове она выделяет N объектов Zombie.

Он должен выделить все N объектов Zombie за одно выделение. 
Затем он должен инициализировать каждого зомби, дав каждому имя. 
Наконец, он должен вернуть указатель на первого зомби. 
Прототип функции выглядит следующим образом:
		Zombie* zombieHorde( int N, std::string name );

Отправьте main, чтобы проверить, что ваша функция zombieHorde работает 
должным образом. Вы можете сделать это, вызвав announce(void) для каждого 
из Зомби. Не забудьте удалить ВСЕХ зомби, когда они вам больше не нужны.
_____________________________________________________________________
Глава IV.

Упражнение 02: HI THIS IS BRAIN
_________________________________________________________________
|                        Упражнение: 02                         |
|_______________________________________________________________|
|                      ПРИВЕТ, ЭТО МОЗГ                         |
|_______________________________________________________________|
|    Каталог сдачи: ex02/                                       |
|_______________________________________________________________|
|    Файлы для передачи: Makefile, main.cpp                     |
|_______________________________________________________________|
|    Запрещенные функции: Нет                                   |
|_______________________________________________________________|

Составьте программу, в которой вы создадите строку, содержащую 
«HI THIS IS BRAIN».

Создайте stringPTR, который является указателем на строку; 
и stringREF, который является ссылкой на строку.

Теперь отобразите адрес в памяти строки. 
Затем отобразите адрес строки с помощью stringPTR и stringREF.
Наконец, отобразите строку с помощью указателя и, наконец, отобразите ее 
с помощью ссылки.

Все, никаких фокусов. 
Цель этого упражнения - развеять мифы о ссылках. 
Это не что-то совершенно новое, это просто еще один синтаксис того, что 
вы уже знаете: адресов. Даже есть какие-то крошечные-маленькие-мелкие детали.

_____________________________________________________________________
Глава V.
Упражнение 03: Unnecessary violence

_________________________________________________________________________
|                        Упражнение: 03                                 |
|_______________________________________________________________________|
|                    Ненужное насилие                                   |
|_______________________________________________________________________|
|   Каталог сдачи: ex03/                                                |
|_______________________________________________________________________|
|   Файлы для передачи: Makefile, main.cpp, Weapon.cpp, Weapon.hpp,     |
|                       HumanA.cpp, HumanA.hpp, HumanB.cpp, HumanB.hpp  |
|_______________________________________________________________________|
|   Запрещенные функции: Нет                                            |
|_______________________________________________________________________|

Создайте класс Weapon, который имеет тип string и метод getType, 
который возвращает константную ссылку на эту строку. 
Конечно, у него также есть setType!

Теперь создайте два класса, HumanA и HumanB, у каждого из которых есть Weapon, 
имя и функция attack (), которая отображает:
NAME attacks with his WEAPON_TYPE

HumanA и HumanB почти одинаковы; есть только две 
крошечные-маленькие-незначительные детали:
• В то время как HumanA принимает Оружие в своем конструкторе, HumanB - нет.
• HumanB не всегда может иметь оружие, но HumanA ВСЕГДА будет вооружен.

Сделайте так, чтобы следующий код в обоих тестовых случаях производил 
атаки «грубой клюшкой с шипами», ЗАТЕМ «другим типом клюшки»:

int main()
{
	{
		Weapon club = Weapon("crude spiked club");

		HumanA bob("Bob", club);
		bob.attack();
		club.setType("some other type of club");
		bob.attack();
	}
	{
		Weapon club = Weapon("crude spiked club");

		HumanB jim("Jim");
		jim.setWeapon(club);
		jim.attack();
		club.setType("some other type of club");
		jim.attack();
	}
}
В каком случае уместно хранить Оружие как указатель? А в качестве ссылки?
Почему?
Это вопросы, которые вы должны задать себе перед тем, как приступить 
к выполнению этого упражнения.
_____________________________________________________________________
Упражнения 4-6 перевести!!!