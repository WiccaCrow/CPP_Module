C ++ - Модуль 08

C ++ Шаблонные контейнеры, итераторы, алгоритмы

Описание: Этот документ содержит тему для Модуля 08 модулей C ++.
Версия: 7
_____________________________________________________________________
СОДЕРЖАНИЕ

I    Общие правила ...............................................   2
II   Правила дня  ................................................   4
III  Упражнение 00: Легкая находка  ..............................   5
III  Упражнение 01: Диапазон .....................................   6
IV   Упражнение 02: Мутировавшая мерзость ........................   8
_____________________________________________________________________
Глава I
Основные правила

Для модулей C ++ вы будете использовать и изучать только C ++ 98.
Цель состоит в том, чтобы вы изучили основы объектно-ориентированного языка 
программирования.
Мы знаем, что современный C ++ сильно отличается во многих аспектах, поэтому, 
если вы хотите стать опытным разработчиком C ++, позже вам понадобится 
современный стандартный C ++. Это будет отправной точкой вашего пути к C ++, 
и вам решать, как продвигаться дальше после 42 Common Core!

• Любая функция, реализованная в заголовке (кроме шаблонов), и любой 
  незащищенный заголовок означает 0 для упражнения.

• Каждый вывод переходит в стандартный вывод и будет заканчиваться новой 
  строкой, если не указано иное.

• Введенные имена файлов должны следовать до буквы, так же как имена классов, 
  имена функций и имена методов.

• Помните: вы сейчас кодите на C ++, а не на C. Следовательно:

      ◦ Следующие функции ЗАПРЕЩЕНЫ, и их использование будет наказано 0, 
        без вопросов: *	alloc, * printf и free.

      ◦ Вам разрешено использовать все, что есть в стандартной библиотеке. 
        ОДНАКО, было бы разумно попытаться использовать версии C ++ функций, 
        к которым вы привыкли в C, вместо того, чтобы просто придерживаться 
        того, что вы знаете, в конце концов, это новый язык. 
        И НЕТ, вам не разрешается использовать STL до тех пор, пока вы не должны 
        (то есть до модуля 08). Это означает, что до тех пор нет 
        векторов / списков / карт / и т. Д. ... 
        или чего-либо, что требует включения <algorithm>.

• Фактически, использование любой явно запрещенной функции или механизма будет 
  наказываться 0 без вопросов.

• Также обратите внимание, что если не указано иное, ключевые слова C ++ 
  «using namespace» и «friend» запрещены. Их использование будет наказано -42, 
  без вопросов.

• Файлы, связанные с классом, всегда будут ClassName.hpp и ClassName.cpp, 
  если не указано иное.

• Каталоги сдачи: ex00 /, ex01 /,. . . , exn /.

• Вы должны внимательно прочитать примеры. Они могут содержать требования, 
  которые не очевидны в описании упражнения.

• Поскольку вам разрешено использовать инструменты C ++, о которых вы узнали с 
  самого начала, вам не разрешается использовать какие-либо внешние библиотеки. 
  И прежде чем вы спросите, это также означает отсутствие C ++ 11 и его 
  производных, Boost или чего-либо еще.

• От вас могут потребовать сдать большое количество занятий. Это может 
  показаться утомительным, если вы не умеете писать скрипт в своем любимом 
  текстовом редакторе.

• Прочтите каждое упражнение ПОЛНОСТЬЮ перед тем, как приступить к нему! 
  Сделай это.

• Используемый компилятор - c ++.

• Ваш код должен быть скомпилирован со следующими флагами: 
  -Wall -Wextra -Werror.

• Каждое из ваших включений должно иметь возможность включаться независимо от 
  других. Включаемые элементы должны содержать все остальные включения, от 
  которых они зависят.

• Если вам интересно, в C ++ стиль кодирования не применяется. 
  Вы можете использовать любой понравившийся стиль, без ограничений. 
  Но помните, что код, который ваш коллега-оценщик не может прочитать, - 
  это код, который они не могут оценить.

• Важный момент: вы НЕ будете оцениваться программой, если это явно не указано 
  в теме. Таким образом, вам предоставляется определенная свобода в выборе 
  выполнения упражнений. Однако помните об ограничениях каждого упражнения и 
  НЕ ленитесь, вы пропустите МНОГО из того, что они могут предложить.

• Не проблема иметь какие-то посторонние файлы в том, что вы передаете, 
  вы можете разделить свой код на большее количество файлов, чем то, что от 
  вас требуется. Не стесняйтесь, если результат не оценивается программой.

• Даже если тема упражнения короткая, стоит потратить на нее некоторое 
  время, чтобы убедиться, что вы понимаете, чего от вас ждут, и что вы 
  сделали это наилучшим образом.

• Один, Тор! Используй свой мозг!!!
_____________________________________________________________________
Глава II.

Особые правила дня

• Вы заметите, что в этом конкретном предмете многие проблемы, которые вас 
  просят решить, могут быть решены НЕ с использованием стандартных контейнеров 
  и НЕ с использованием стандартных алгоритмов. 
  Однако их использование и является целью, и если вы не приложите все усилия 
  для использования стандартных контейнеров и алгоритмов там, где это уместно, 
  вы получите очень плохую оценку, какой бы функциональной ни была ваша работа. 
  Пожалуйста, не будь таким ленивым.
_____________________________________________________________________
Глава III.
Упражнение 00:  Easy find

_________________________________________________________
|           Упражнение: 00                              |
|_______________________________________________________|
|           Упражнение 00: Легко найти                  |
|_______________________________________________________|
|   Каталог сдачи: ex00/                                |
|_______________________________________________________|
|   Файлы для передачи: easyfind.hpp main.cpp           |
|                                                       |
|_______________________________________________________|
|   Запрещенные функции: никакие                         |
|_______________________________________________________|

Легко начать с правильной ноги ...

Создайте шаблонную функцию easyfind, основанную на типе T, 
которая принимает T и int.

Предположим, что T является контейнером int, и найдите первое вхождение 
второго параметра в первом параметре.

Если его не удается найти, обработайте ошибку либо с помощью исключения, 
либо с помощью возвращаемого значения ошибки.

Возьмите идеи из того, как работают стандартные контейнеры.
Конечно, вы предоставите основную функцию, которая тщательно ее протестирует.
_____________________________________________________________________
Глава IV.

Упражнение 01: Span

_________________________________________________________
|           Упражнение: 01                              |
|_______________________________________________________|
|           Упражнение 01: диапазон                     |
|_______________________________________________________|
|   Каталог сдачи: ex01/                                |
|_______________________________________________________|
|   Файлы для передачи: : span.cpp span.hpp main.cpp    |
|                                                       |
|_______________________________________________________|
|   Запрещенные функции: нет                            |
|_______________________________________________________|

Создайте класс, в котором вы можете хранить N int. 
N будет беззнаковым целым числом и будет передано конструктору в качестве его 
единственного параметра.

У этого класса будет функция для хранения единственного числа (addNumber), 
которое будет использоваться для его заполнения. 
Попытка добавить новый номер, если в объекте уже хранится N из них, 
является ошибкой и должна привести к исключению.

Теперь вы создадите две функции, shortestSpan и longestSpan, которые будут 
определять соответственно самый короткий и самый длинный промежуток между всеми 
числами, содержащимися в объекте, и возвращать его. 
Если числа не сохранены или только одно, диапазона для поиска нет, и вы 
выдадите исключение.

Ниже приведен (слишком короткий) пример основной тестовой программы и 
связанных с ней выходных данных. 
Конечно, ваш main будет более тщательным, чем это. 
Вы должны протестировать как минимум 10 000 номеров. 
Больше было бы хорошо. 
Также было бы очень хорошо, если бы вы могли складывать числа, 
передавая диапазон итераторов, что позволило бы избежать раздражения, 
связанного с тысячами вызовов addNumber ...

int main()
{
    Span sp = Span(5);

    sp.addNumber(5);
    sp.addNumber(3);
    sp.addNumber(17);
    sp.addNumber(9);
    sp.addNumber(11);

    std::cout << sp.shortestSpan() << std::endl;
    std::cout << sp.longestSpan() << std::endl;
}

$> ./ex01
2
14
$>
_____________________________________________________________________
Глава V.

Упражнение 02:  Mutated abomination

_________________________________________________________________
|                        Упражнение: 02                         |
|_______________________________________________________________|
|                       Мутировавшая мерзость                   |
|_______________________________________________________________|
|    Каталог сдачи: ex02/                                       |
|_______________________________________________________________|
|   Файлы для передачи:   mutantstack.cpp mutantstack.hpp       |
|                         main.cpp                              |
|_______________________________________________________________|
|   Запрещенные функции: нет                                    |
|_______________________________________________________________|

Теперь, когда закуски готовы, давайте займемся отвратительными вещами.

Контейнер std :: stack ОЧЕНЬ крутой, но это один из немногих контейнеров STL, 
который НЕ повторяется (NOT iterable). Это очень плохо. Но зачем с этим 
мириться, если мы можем просто сыграть в Бога и разделать его, чтобы добавить 
что-то, что нам нравится?

Вы вставите эту способность в контейнер std :: stack, чтобы исправить эту 
серьезную несправедливость.

Создайте класс MutantStack, который будет реализован в терминах std :: stack и 
предложит все его функции-члены, только он также будет предлагать итератор.

Ниже приведен пример кода, вывод которого должен быть таким же, как если бы мы 
заменили MutantStack, например, на std :: list. 
Вы, конечно же, предоставите тесты для всего этого в своей основной функции.

int main()
{
	MutantStack<int> mstack;

	mstack.push(5);
	mstack.push(17);

	std::cout << mstack.top() << std::endl;

	mstack.pop();

	std::cout << mstack.size() << std::endl;

	mstack.push(3);
	mstack.push(5);
	mstack.push(737);
	//[...]
	mstack.push(0);

	MutantStack<int>::iterator it = mstack.begin();
	MutantStack<int>::iterator ite = mstack.end();

	++it;
	--it;
	while (it != ite)
	{
		std::cout << *it << std::endl;
		++it;
	}
	std::stack<int> s(mstack);
	return 0;
}
