C ++ - Модуль 06

C ++ Приведения

Описание: Этот документ содержит тему модуля 06 модулей C ++.
Версия: 5
_____________________________________________________________________
СОДЕРЖАНИЕ

I   Общие правила ................................................   2
II  Бонусные правил ..............................................   4
III Упражнение 00: Скалярное преобразование ......................   5
IV  Упражнение 01: Сериализация ..................................   7
V   Упражнение 02: Определите настоящий тип ......................   8

_____________________________________________________________________
Глава I
Основные правила

Для модулей C ++ вы будете использовать и изучать только C ++ 98.
Цель состоит в том, чтобы вы изучили основы объектно-ориентированного языка 
программирования.
Мы знаем, что современный C ++ сильно отличается во многих аспектах, поэтому, 
если вы хотите стать опытным разработчиком C ++, позже вам понадобится 
современный стандартный C ++. Это будет отправной точкой вашего пути к C ++, 
и вам решать, как продвигаться дальше после 42 Common Core!

• Любая функция, реализованная в заголовке (кроме шаблонов), и любой 
  незащищенный заголовок означает 0 для упражнения.

• Каждый вывод переходит в стандартный вывод и будет заканчиваться новой 
  строкой, если не указано иное.

• Введенные имена файлов должны следовать до буквы, так же как имена классов, 
  имена функций и имена методов.

• Помните: вы сейчас кодите на C ++, а не на C. Следовательно:

      ◦ Следующие функции ЗАПРЕЩЕНЫ, и их использование будет наказано 0, 
        без вопросов: *	alloc, * printf и free.

      ◦ Вам разрешено использовать все, что есть в стандартной библиотеке. 
        ОДНАКО, было бы разумно попытаться использовать версии C ++ функций, 
        к которым вы привыкли в C, вместо того, чтобы просто придерживаться 
        того, что вы знаете, в конце концов, это новый язык. 
        И НЕТ, вам не разрешается использовать STL до тех пор, пока вы не должны 
        (то есть до модуля 08). Это означает, что до тех пор нет 
        векторов / списков / карт / и т. Д. ... 
        или чего-либо, что требует включения <algorithm>.

• Фактически, использование любой явно запрещенной функции или механизма будет 
  наказываться 0 без вопросов.

• Также обратите внимание, что если не указано иное, ключевые слова C ++ 
  «using namespace» и «friend» запрещены. Их использование будет наказано -42, 
  без вопросов.

• Файлы, связанные с классом, всегда будут ClassName.hpp и ClassName.cpp, 
  если не указано иное.

• Каталоги сдачи: ex00 /, ex01 /,. . . , exn /.

• Вы должны внимательно прочитать примеры. Они могут содержать требования, 
  которые не очевидны в описании упражнения.

• Поскольку вам разрешено использовать инструменты C ++, о которых вы узнали с 
  самого начала, вам не разрешается использовать какие-либо внешние библиотеки. 
  И прежде чем вы спросите, это также означает отсутствие C ++ 11 и его 
  производных, Boost или чего-либо еще.

• От вас могут потребовать сдать большое количество занятий. Это может 
  показаться утомительным, если вы не умеете писать скрипт в своем любимом 
  текстовом редакторе.

• Прочтите каждое упражнение ПОЛНОСТЬЮ перед тем, как приступить к нему! 
  Сделай это.

• Используемый компилятор - c ++.

• Ваш код должен быть скомпилирован со следующими флагами: 
  -Wall -Wextra -Werror.

• Каждое из ваших включений должно иметь возможность включаться независимо от 
  других. Включаемые элементы должны содержать все остальные включения, от 
  которых они зависят.

• Если вам интересно, в C ++ стиль кодирования не применяется. 
  Вы можете использовать любой понравившийся стиль, без ограничений. 
  Но помните, что код, который ваш коллега-оценщик не может прочитать, - 
  это код, который они не могут оценить.

• Важный момент: вы НЕ будете оцениваться программой, если это явно не указано 
  в теме. Таким образом, вам предоставляется определенная свобода в выборе 
  выполнения упражнений. Однако помните об ограничениях каждого упражнения и 
  НЕ ленитесь, вы пропустите МНОГО из того, что они могут предложить.

• Не проблема иметь какие-то посторонние файлы в том, что вы передаете, 
  вы можете разделить свой код на большее количество файлов, чем то, что от 
  вас требуется. Не стесняйтесь, если результат не оценивается программой.

• Даже если тема упражнения короткая, стоит потратить на нее некоторое 
  время, чтобы убедиться, что вы понимаете, чего от вас ждут, и что вы 
  сделали это наилучшим образом.

• Один, Тор! Используй свой мозг!!!
_____________________________________________________________________
Глава II.
Бонусные правила
• В каждом упражнении любая ситуация применения каста решается 
определенным броском. Оценка проверит, соответствует ли ваш выбор ожидаемому составу(cast).
_____________________________________________________________________
Глава III.
Упражнение 00:  Scalar conversion

_________________________________________________________
|           Упражнение: 00                              |
|_______________________________________________________|
|        Упражнение 00: Скалярное преобразование        |
|_______________________________________________________|
|   Каталог сдачи: ex00/                                |
|_______________________________________________________|
|   Файлы для передачи: Makefile и  Любой нужный вам    |
|             файл                                      |
|_______________________________________________________|
|   Допустимые функции: Любая функция для               |
|    преобразования из строки в int, float или double.  |
|    Это поможет, но не полностью.                      |
|_______________________________________________________|

Напишите программу, которая принимает строковое представление 
C++ literal value(в его наиболее распространенной форме) в качестве параметра. 
Этот литерал должен принадлежать к одному из следующих скалярных типов: 
char, 
int, 
float или 
double. 
Будет использоваться только десятичное представление.

Примеры буквальных значений char: 'c', 'a' ... 
Для упрощения, обратите внимание, что: 
неотображаемые символы не могут быть переданы в качестве параметра 
вашей программе, и если преобразование в char не отображается, 
выведите уведомление вместо этого.

Примеры буквальных значений int: 0, -42, 42 ...
Примеры значений литералов с плавающей запятой: 0.0f, -4.2f, 4.2f ... 
Вы также можете принять эти псевдолитералы, как вы знаете, 
для науки: -inff, + inff и nanf.

Примеры значений двойных литералов: 0.0, -4.2, 4.2 ... 
Вы также можете принять эти псевдолитералы, как вы знаете, 
для развлечения: -inf, + inf и nan.

Ваша программа должна определить тип литерала, получить этот литерал 
правильного типа (чтобы он больше не была строкой), затем явно преобразовать 
его в каждый из трех других типов и отобразить результаты с использованием 
того же форматирования, что и ниже. Если преобразование не имеет смысла или 
выходит за рамки, укажите, что преобразование невозможно. 
Вы можете включить любой заголовок, необходимый для обработки числовых 
ограничений и специальных значений.

Примеры:

./convert 0
char: Non displayable
int: 0
float: 0.0f
double: 0.0
./convert nan
char: impossible
int: impossible
float: nanf
double: nan
./convert 42.0f
char: '*'
int: 42
float: 42.0f
double: 42.0
_____________________________________________________________________
Глава IV.

Упражнение 01: Serialization

_________________________________________________________
|           Упражнение: 01                              |
|_______________________________________________________|
|           Упражнение 01: Сериализация.                |
|_______________________________________________________|
|   Каталог сдачи: ex01/                                |
|_______________________________________________________|
|   Файлы для передачи: : Любой нужный вам файл и       |
|                         Makefile                      |
|_______________________________________________________|
|   Разрешенные функции: нет                            |
|_______________________________________________________|


Напишите функцию 
"uintptr_t serialize(Data* ptr);". 
Эта функция вернет параметр в целочисленном типе.

Напишите функцию 
"Data* deserialize(uintptr_t raw);". 
Эта функция вернет необработанные данные, которые вы создали с помощью «сериализации», в структуру Data.

Оберните эти две функции в программу, которая доказывает, 
что все работает так, как задумано.

Вы должны создать допустимую структуру данных.
Возьмите адрес данных, используйте сериализацию на нем.
Отправьте возвращаемое значение в deserialize.
Убедитесь, что возвращаемое значение равно первому указателю.
Не забудьте указать используемую вами структуру данных.

_____________________________________________________________________
Глава IV.

Упражнение 02:  Identify real type

_________________________________________________________________
|                        Упражнение: 02                         |
|_______________________________________________________________|
|            Упражнение 02: Определите настоящий тип.           |
|_______________________________________________________________|
|    Каталог сдачи: ex02/                                       |
|_______________________________________________________________|
|   Файлы для передачи:   Любой нужный вам файл и               |
|                         Makefile                              |
|_______________________________________________________________|
|   Разрешенные функции: нет                                    |
|_______________________________________________________________|

Создайте класс Base, который имеет только общедоступный виртуальный деструктор. Создайте три пустых класса A, B и C, которые публично наследуют от Base.

Напишите функцию «Base * generate (void);» который случайным образом создает экземпляры A, B или C и возвращает экземпляр как базовый указатель. Не стесняйтесь использовать что угодно для случайности.

Напишите функцию "void identify (Base * p);" который отображает «A», «B» или «C» в соответствии с реальным типом p.

Напишите функцию "void identify (Base & p);" Вы никогда не должны использовать указатель внутри этой функции. который отображает «A», «B» или «C» в соответствии с реальным типом p.

Оберните эти функции в программу, которая доказывает, что все работает по назначению.
<typeinfo> запрещено.
