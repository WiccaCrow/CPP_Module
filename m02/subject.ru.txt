C++ - Module 02

Ad-hoc polymorphism, operators overload and
orthodox canonical classes

Описание: Этот документ содержит тему для модуля 02 модулей C ++.
Версия: 7
_____________________________________________________________________
СОДЕРЖАНИЕ

II 	Бонусные правила .............................................   4
III 	Упражнение 00: Мой первый православный класс .................   5
IV 	Упражнение 01: На пути к более полезному классу 
                       фиксированной точки .......................   7
V 	Упражнение 02: теперь поговорим ..............................   9
VI 	Упражнение 03: BSP ...........................................  11

I General rules
II Bonus rules
III Exercise 00: My First Orthodox Class
IV Exercise 01: Towards a more useful fixed point class
V Exercise 02: Now we’re talking
VI Exercise 03: BSP

_____________________________________________________________________
Глава I
Основные правила

Для модулей C ++ вы будете использовать и изучать только C ++ 98.
Цель состоит в том, чтобы вы изучили основы объектно-ориентированного языка 
программирования.
Мы знаем, что современный C ++ сильно отличается во многих аспектах, поэтому, 
если вы хотите стать опытным разработчиком C ++, позже вам понадобится 
современный стандартный C ++. Это будет отправной точкой вашего пути к C ++, 
и вам решать, как продвигаться дальше после 42 Common Core!

• Любая функция, реализованная в заголовке (кроме шаблонов), и любой 
  незащищенный заголовок означает 0 для упражнения.

• Каждый вывод переходит в стандартный вывод и будет заканчиваться новой 
  строкой, если не указано иное.

• Введенные имена файлов должны следовать до буквы, так же как имена классов, 
  имена функций и имена методов.

• Помните: вы сейчас кодите на C ++, а не на C. Следовательно:

      ◦ Следующие функции ЗАПРЕЩЕНЫ, и их использование будет наказано 0, 
        без вопросов: *	alloc, * printf и free.

      ◦ Вам разрешено использовать все, что есть в стандартной библиотеке. 
        ОДНАКО, было бы разумно попытаться использовать версии C ++ функций, 
        к которым вы привыкли в C, вместо того, чтобы просто придерживаться 
        того, что вы знаете, в конце концов, это новый язык. 
        И НЕТ, вам не разрешается использовать STL до тех пор, пока вы не должны 
        (то есть до модуля 08). Это означает, что до тех пор нет 
        векторов / списков / карт / и т. Д. ... 
        или чего-либо, что требует включения <algorithm>.

• Фактически, использование любой явно запрещенной функции или механизма будет 
  наказываться 0 без вопросов.

• Также обратите внимание, что если не указано иное, ключевые слова C ++ 
  «using namespace» и «friend» запрещены. Их использование будет наказано -42, 
  без вопросов.

• Файлы, связанные с классом, всегда будут ClassName.hpp и ClassName.cpp, 
  если не указано иное.

• Каталоги сдачи: ex00 /, ex01 /,. . . , exn /.

• Вы должны внимательно прочитать примеры. Они могут содержать требования, 
  которые не очевидны в описании упражнения.

• Поскольку вам разрешено использовать инструменты C ++, о которых вы узнали с 
  самого начала, вам не разрешается использовать какие-либо внешние библиотеки. 
  И прежде чем вы спросите, это также означает отсутствие C ++ 11 и его 
  производных, Boost или чего-либо еще.

• От вас могут потребовать сдать большое количество занятий. Это может 
  показаться утомительным, если вы не умеете писать скрипт в своем любимом 
  текстовом редакторе.

• Прочтите каждое упражнение ПОЛНОСТЬЮ перед тем, как приступить к нему! 
  Сделай это.

• Используемый компилятор - c ++.

• Ваш код должен быть скомпилирован со следующими флагами: 
  -Wall -Wextra -Werror.

• Каждое из ваших включений должно иметь возможность включаться независимо от 
  других. Включаемые элементы должны содержать все остальные включения, от 
  которых они зависят.

• Если вам интересно, в C ++ стиль кодирования не применяется. 
  Вы можете использовать любой понравившийся стиль, без ограничений. 
  Но помните, что код, который ваш коллега-оценщик не может прочитать, - 
  это код, который они не могут оценить.

• Важный момент: вы НЕ будете оцениваться программой, если это явно не указано 
  в теме. Таким образом, вам предоставляется определенная свобода в выборе 
  выполнения упражнений. Однако помните об ограничениях каждого упражнения и 
  НЕ ленитесь, вы пропустите МНОГО из того, что они могут предложить.

• Не проблема иметь какие-то посторонние файлы в том, что вы передаете, 
  вы можете разделить свой код на большее количество файлов, чем то, что от 
  вас требуется. Не стесняйтесь, если результат не оценивается программой.

• Даже если тема упражнения короткая, стоит потратить на нее некоторое 
  время, чтобы убедиться, что вы понимаете, чего от вас ждут, и что вы 
  сделали это наилучшим образом.

• Один, Тор! Используй свой мозг!!!
_____________________________________________________________________
Глава II Бонусные правила

• С этого момента каждый создаваемый вами класс ДОЛЖЕН иметь ортодоксальную 
  каноническую форму: по крайней мере, 
  
  один конструктор по умолчанию, 
  конструктор копирования, 
  перегрузка оператора присваивания и 
  деструктор. 

  Больше не будем спрашивать.
_____________________________________________________________________


Глава III.
Упражнение 00: My First Orthodox Class

_________________________________________________________
|           Упражнение: 00                              |
|_______________________________________________________|
|           Мой первый ортодоксальный класс             |
|_______________________________________________________|
|   Каталог сдачи: ex00/                                |
|_______________________________________________________|
|   Файлы для передачи: Makefile, main.cpp,             |
|                       Fixed.hpp and Fixed.cpp         |
|_______________________________________________________|
|   Запрещенные функции: Нет                            |
|_______________________________________________________|

Вы знаете целые числа, а также числа с плавающей запятой. Как мило.

Прочтите эту трехстраничную статью (1, 2, 3), чтобы убедиться, что вы этого не делаете. Давай, прочти.
|___
| 1
|https://www.cprogramming.com/tutorial/floating_point/understanding_floating_point.html
|
|___
| 2
|https://www.cprogramming.com/tutorial/floating_point/understanding_floating_point_representation.html
|
|___
| 3
|https://www.cprogramming.com/tutorial/floating_point/understanding_floating_point_printing.html
|
|___
До сегодняшнего дня любые числа, которые вы использовали в своих программах, 
были в основном целыми числами или числами с плавающей запятой или любыми их 
вариантами (короткими, символьными, длинными, двойными и т. Д.). 
Из вашего предыдущего чтения можно с уверенностью предположить, что целые числа 
и числа с плавающей запятой имеют противоположные характеристики.

Но сегодня это изменится. Вы откроете для себя новый удивительный тип чисел: 
числа с фиксированной запятой! 
Числа с фиксированной запятой, которые всегда отсутствуют в большинстве языков 
скалярных типов, предлагают ценный баланс между производительностью, точностью, 
диапазоном и точностью, что объясняет, почему эти числа широко используются в 
графике, звуке или научном программировании, и это лишь некоторые из них.

Поскольку в C ++ отсутствуют числа с фиксированной запятой, вы собираетесь 
добавить их сегодня. Я бы порекомендовал для начала эту статью
https://inst.eecs.berkeley.edu//~cs61c/sp06/handout/fixedpt.html
 из Беркли. Если это хорошо для них, это хорошо для вас. Если вы не знаете, что такое Беркли, прочтите этот
https://en.wikipedia.org/wiki/University_of_California,_Berkeley#Notable_alumni.2C_faculty.2C_and_staff
 раздел их страницы в Википедии.



Напишите ортодоксальный класс для представления чисел с фиксированной запятой:

• Частные члены:

	◦ Целое число для хранения значения фиксированной точки.
	◦ Статическое постоянное целое число для хранения количества дробных битов. Эта константа всегда
 	будет литеральной 8.

• Публичные члены:
	◦ Конструктор по умолчанию, который инициализирует значение фиксированной точки равным 0.
	◦ Деструктор.
	◦ Конструктор копирования.
	◦ Перегрузка оператора присваивания.
	◦ Функция-член int getRawBits (void) const; который возвращает исходное значение фиксированной точки.
	◦ Функция-член void setRawBits (int const raw); который устанавливает исходное значение фиксированной точки.
Код:
===========
==
#include <iostream>

int main( void ) {

	Fixed a;
	Fixed b( a );
	Fixed c;

	c = b;

	std::cout << a.getRawBits() << std::endl;
	std::cout << b.getRawBits() << std::endl;
	std::cout << c.getRawBits() << std::endl;

	return 0;
}
==
===========
Должен вывести что-то вроде:
===========
==
$> ./a.out
Default constructor called
Copy constructor called
Assignation operator called // <-- This line may be missing depending on your implementation
getRawBits member function called
Default constructor called
Assignation operator called
getRawBits member function called
getRawBits member function called
0
getRawBits member function called
0
getRawBits member function called
0
Destructor called
Destructor called
Destructor called
$>
==
===========
_____________________________________________________________________
Глава IV.

Упражнение 01: Towards a more useful fixed point class

_________________________________________________________
|           Упражнение: 01                              |
|_______________________________________________________|
|  На пути к более полезному классу фиксированной точки |
|_______________________________________________________|
|   Каталог сдачи: ex01/                                |
|_______________________________________________________|
|   Файлы для передачи: : Makefile, main.cpp,           |
|                       Fixed.hpp and Fixed.cpp         |
|_______________________________________________________|
|   Запрещенные функции: roundf (from <cmath>)          |
|_______________________________________________________|

Хорошо, ex00 было хорошим началом, но наш класс по-прежнему довольно бесполезен, 
поскольку может представлять только значение фиксированной точки 0,0. 
Добавьте в класс следующие общедоступные конструкторы и общедоступные функции-члены:

• Конструктор, который принимает в качестве параметра постоянное целое число и 
  преобразует его в соответствующее значение фиксированной (8) точки. 
  Значение дробных битов инициализируется как в ex00.

• Конструктор, который принимает в качестве параметра постоянную плавающую точку и 
  преобразует его в соответствующее значение с фиксированной (8) точкой. 
  Значение дробных битов инициализируется как в ex00.

• Функция-член     float toFloat(void) const;      который преобразует значение 
  с фиксированной запятой в значение с плавающей запятой.

• Функция-член     int toInt(void) const;          который преобразует значение 
  с фиксированной точкой в ​​целочисленное значение.



Вы также добавите следующую перегрузку функции в файлы заголовка (объявления) и источника (определения):

• Перегрузка оператора «, который вставляет представление с плавающей запятой 
  значения с фиксированной запятой в поток вывода параметра.
An overload to the « operator that inserts a floating point representation of the fixed point value into the parameter output stream.


Код:
=====
==
#include <iostream>

int    main( void ) {

       Fixed a;
       Fixed const b( 10 ); 
       Fixed const c( 42.42f ); 
       Fixed const d( b );

       a = Fixed( 1234.4321f );

       std::cout << "a is " << a << std::endl;
       std::cout << "b is " << b << std::endl;
       std::cout << "c is " << c << std::endl;
       std::cout << "d is " << d << std::endl;

       std::cout << "a is " << a.toInt() << " as integer" << std::endl;
       std::cout << "b is " << b.toInt() << " as integer" << std::endl;
       std::cout << "c is " << c.toInt() << " as integer" << std::endl;
       std::cout << "d is " << d.toInt() << " as integer" << std::endl;

       return 0; 
}
==
=====

Должен вывести что-то вроде:
=====
==

> ./a.out
Default constructor called
Int constructor called
Float constructor called
Copy constructor called
Assignation operator called
Float constructor called
Assignation operator called
Destructor called
a is 1234.43
b is 10
c is 42.4219
d is 10
a is 1234 as integer
b is 10 as integer
c is 42 as integer
d is 10 as integer
Destructor called
Destructor called
Destructor called
Destructor called
$>

==
=====






_____________________________________________________________________
Глава V.

Упражнение 02: Now we’re talking

_________________________________________________________________
|                        Упражнение: 02                         |
|_______________________________________________________________|
|                      Сейчас мы говорим                        |
|_______________________________________________________________|
|    Каталог сдачи: ex02/                                       |
|_______________________________________________________________|
|    Файлы для передачи: Makefile, main.cpp,                    |
|                        Fixed.hpp and Fixed.cpp                |
|_______________________________________________________________|
|    Запрещенные функции: roundf (from <cmath>)                 |
|_______________________________________________________________|

Мы приближаемся. Добавьте в класс следующие перегрузки общедоступных операторов-членов:

• Шесть операторов сравнения:>, <,> =, <=, == и! =.

• Четыре арифметических оператора: +, -, * и /.

• Операторы пре-инкремента, пост-инкремента, пре-декремента и пост-декремента, 
  которые увеличивают или уменьшают значение фиксированной точки от наименьшего 
  представимого ε, такого как 1 + ε> 1.

Добавьте в класс следующие перегрузки общедоступных статических функций-членов:

• Статическая функция-член min, которая принимает ссылки на два значения с 
  фиксированной точкой и возвращает ссылку на наименьшее значение, и перегрузку, 
  которая принимает ссылки на два постоянных значения с фиксированной точкой и 
  возвращает ссылку на наименьшее постоянное значение.

• Статическая функция-член max, которая принимает ссылки на два значения с 
  фиксированной точкой и возвращает ссылку на наибольшее значение, и перегрузку, 
  которая принимает ссылки на два постоянных значения с фиксированной точкой и 
  возвращает ссылку на наибольшее постоянное значение.

Вам решать протестировать каждую функцию вашего класса, кроме короткого кода:
=====
==
#include <iostream>

int  main( void ) { 

     Fixed   a;
     Fixed const b( Fixed( 5.05f ) * Fixed( 2 ) );

     std::cout << a << std::endl;
     std::cout << ++a << std::endl;
     std::cout << a << std::endl;
     std::cout << a++ << std::endl;
     std::cout << a << std::endl;

     std::cout << b << std::endl;

     std::cout << Fixed::max( a, b ) << std::endl;

     return 0; 
}
==
=====

Должен вывести что-то вроде (я удалил журналы ctors / dtor):
=====
==
$> ./a.out
0
0.00390625
0.00390625
0.00390625
0.0078125
10.1016
10.1016 
$>
==
=====
_____________________________________________________________________
Глава VI 
Упражнение 03: BSP

_________________________________________________________________________
|                        Упражнение: 03                                 |
|_______________________________________________________________________|
|                      Упражнение 03: BSP                               |
|_______________________________________________________________________|
|   Каталог сдачи: ex03/                                                |
|_______________________________________________________________________|
|   Файлы для передачи: Makefile, main.cpp, Fixed.hpp, Fixed.cpp,       |
|                       Point.hpp, Point.cpp, and bsp.cpp               |
|_______________________________________________________________________|
|   Запрещенные функции: roundf (from <cmath>)                          |
|_______________________________________________________________________|

!!!!! Это упражнение не требуется для проверки этого модуля.


Теперь, когда у вас есть полностью рабочий класс с фиксированной точкой, 
было бы здорово использовать его для чего-нибудь полезного. Вы собираетесь 
написать функцию, которая указывает, находится ли точка внутри треугольника 
или нет. Очень полезно, не правда ли?

!!!!!info
!!  BSP stands for Binary space partitioning.  You are welcome :)
!!  BSP означает разделение двоичного пространства. Добро пожаловать :)
!!!!!

Начнем с написания ортодоксального класса Point для представления двухмерной точки:

• Частные члены:
     ◦ A Fixed const x
     ◦ A Fixed const y
     ◦ Все остальное, что вы считаете полезным.

• Публичные члены:
     ◦ Конструктор по умолчанию, который инициализирует x и y равными 0.
     ◦ деструктор.
     ◦ Конструктор копирования.
     ◦ Конструктор, который принимает два const числа с плавающей запятой 
       в качестве параметров и инициализирует x и y этими значениями.
     ◦ Перегрузка оператора присваивания.
     ◦ Все остальное, что вы считаете полезным.


Теперь вам нужно написать функцию bsp:

• Первые три параметра - это вершины нашего любимого треугольника.

• Четвертый пункт - это точка, которую мы оцениваем.

• Возвращаемое значение - True, если точка находится внутри треугольника, 
  в противном случае возвращаемое значение должно быть False. 
  Это означает, что если точка является вершиной или точкой, 
  находящейся на краю, возвращаемое значение должно быть False.

• Следовательно, прототип функции:
bool bsp( Point const a, Point const b, Point const c, Point const point);

Не забудьте сдать свою основную часть тестов, чтобы доказать, 
что ваш класс работает так, как задумано.
