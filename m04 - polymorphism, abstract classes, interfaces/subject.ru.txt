C ++ - Модуль 04

Полиморфизм подтипов, абстрактные классы, интерфейсы

Описание: Этот документ содержит тему для модуля 04 модулей C ++.
Версия: 10
_____________________________________________________________________
СОДЕРЖАНИЕ

I       Общие правила ................................................   2
II 	Упражнение 00: Полиморфизм ...................................   4
III     Упражнение 01: Я не хочу поджигать мир .......................   6
IV 	Упражнение 02: абстрактный класс .............................   8
V 	Упражнение 03: Интерфейс и резюме ............................   9

_____________________________________________________________________
Глава I
Основные правила

Для модулей C ++ вы будете использовать и изучать только C ++ 98.
Цель состоит в том, чтобы вы изучили основы объектно-ориентированного языка 
программирования.
Мы знаем, что современный C ++ сильно отличается во многих аспектах, поэтому, 
если вы хотите стать опытным разработчиком C ++, позже вам понадобится 
современный стандартный C ++. Это будет отправной точкой вашего пути к C ++, 
и вам решать, как продвигаться дальше после 42 Common Core!

• Любая функция, реализованная в заголовке (кроме шаблонов), и любой 
  незащищенный заголовок означает 0 для упражнения.

• Каждый вывод переходит в стандартный вывод и будет заканчиваться новой 
  строкой, если не указано иное.

• Введенные имена файлов должны следовать до буквы, так же как имена классов, 
  имена функций и имена методов.

• Помните: вы сейчас кодите на C ++, а не на C. Следовательно:

      ◦ Следующие функции ЗАПРЕЩЕНЫ, и их использование будет наказано 0, 
        без вопросов: *	alloc, * printf и free.

      ◦ Вам разрешено использовать все, что есть в стандартной библиотеке. 
        ОДНАКО, было бы разумно попытаться использовать версии C ++ функций, 
        к которым вы привыкли в C, вместо того, чтобы просто придерживаться 
        того, что вы знаете, в конце концов, это новый язык. 
        И НЕТ, вам не разрешается использовать STL до тех пор, пока вы не должны 
        (то есть до модуля 08). Это означает, что до тех пор нет 
        векторов / списков / карт / и т. Д. ... 
        или чего-либо, что требует включения <algorithm>.

• Фактически, использование любой явно запрещенной функции или механизма будет 
  наказываться 0 без вопросов.

• Также обратите внимание, что если не указано иное, ключевые слова C ++ 
  «using namespace» и «friend» запрещены. Их использование будет наказано -42, 
  без вопросов.

• Файлы, связанные с классом, всегда будут ClassName.hpp и ClassName.cpp, 
  если не указано иное.

• Каталоги сдачи: ex00 /, ex01 /,. . . , exn /.

• Вы должны внимательно прочитать примеры. Они могут содержать требования, 
  которые не очевидны в описании упражнения.

• Поскольку вам разрешено использовать инструменты C ++, о которых вы узнали с 
  самого начала, вам не разрешается использовать какие-либо внешние библиотеки. 
  И прежде чем вы спросите, это также означает отсутствие C ++ 11 и его 
  производных, Boost или чего-либо еще.

• От вас могут потребовать сдать большое количество занятий. Это может 
  показаться утомительным, если вы не умеете писать скрипт в своем любимом 
  текстовом редакторе.

• Прочтите каждое упражнение ПОЛНОСТЬЮ перед тем, как приступить к нему! 
  Сделай это.

• Используемый компилятор - c ++.

• Ваш код должен быть скомпилирован со следующими флагами: 
  -Wall -Wextra -Werror.

• Каждое из ваших включений должно иметь возможность включаться независимо от 
  других. Включаемые элементы должны содержать все остальные включения, от 
  которых они зависят.

• Если вам интересно, в C ++ стиль кодирования не применяется. 
  Вы можете использовать любой понравившийся стиль, без ограничений. 
  Но помните, что код, который ваш коллега-оценщик не может прочитать, - 
  это код, который они не могут оценить.

• Важный момент: вы НЕ будете оцениваться программой, если это явно не указано 
  в теме. Таким образом, вам предоставляется определенная свобода в выборе 
  выполнения упражнений. Однако помните об ограничениях каждого упражнения и 
  НЕ ленитесь, вы пропустите МНОГО из того, что они могут предложить.

• Не проблема иметь какие-то посторонние файлы в том, что вы передаете, 
  вы можете разделить свой код на большее количество файлов, чем то, что от 
  вас требуется. Не стесняйтесь, если результат не оценивается программой.

• Даже если тема упражнения короткая, стоит потратить на нее некоторое 
  время, чтобы убедиться, что вы понимаете, чего от вас ждут, и что вы 
  сделали это наилучшим образом.

• Один, Тор! Используй свой мозг!!!
_____________________________________________________________________
Глава II.
Упражнение 00: Polymorphism

_________________________________________________________
|           Упражнение: 00                              |
|_______________________________________________________|
|           Полиморфизм                                 |
|_______________________________________________________|
|   Каталог сдачи: ex00/                                |
|_______________________________________________________|
|   Файлы для передачи: Makefile, main.cpp,             |
|                все остальные файлы, которые вам нужны |
|_______________________________________________________|
|   Запрещенные функции: Нет                            |
|_______________________________________________________|

Для каждого упражнения ваш main должен проверять все.
Конструкторы и деструкторы каждого класса должны иметь специфический вывод.

Создайте простой и полный базовый класс Animal.

Класс животных получит один защищенный (protected) атрибут:
 • std::string type;

Создайте класс Dog, унаследованный от Animal.
Создайте класс Cat, унаследованный от Animal.

(для класса животных тип можно оставить пустым или присвоить любое значение).

Каждый класс должен указать свое имя в поле Тип, например:
Тип класса Dog должен быть инициализирован как «Dog».
Каждое животное должно уметь использовать метод makeSound ().

Этот метод отобразит соответствующее сообщение на стандартных выходных данных 
в зависимости от класса.

int main()
{
    const Animal* meta = new Animal();
    const Animal* j = new Dog();
    const Animal* i = new Cat();
    std::cout << j->getType() << " " << std::endl;
    std::cout << i->getType() << " " << std::endl;
    i->makeSound(); //will output the cat sound!
    j->makeSound();
    meta->makeSound();
    ...
}

Это должно вывести характерный makeSound классу Dog и cat, а не животного.
Чтобы быть уверенным, вы создадите класс WrongCat, 
наследующий класс WrongAnimal, 
который будет выводить функцию makeSound () WrongAnimal при тестировании 
в тех же условиях.
_____________________________________________________________________
Глава III.

Упражнение 01: я не хочу поджигать мир

_________________________________________________________
|           Упражнение: 01                              |
|_______________________________________________________|
|           Упражнение 01: я не хочу поджигать мир      |
|_______________________________________________________|
|   Каталог сдачи: ex01/                                |
|_______________________________________________________|
|   Файлы для передачи: : Makefile, main.cpp, +         |
|           плюс необходимые файлы для ваших тестов     |
|_______________________________________________________|
|   Запрещенные функции: нет                            |
|_______________________________________________________|

Вы будете повторно использовать классы Ex00.
Создайте один класс под названием Brain.
Brain будет содержать массив из 100 std :: string, называемый ideas.
Теперь у собак и кошек будет личный Brain * атрибут.

Не у каждого животного есть мозг!

После создания Dog и Cat инициализируют свой Brain* новым Brain();

При уничтожении Dog и Cat удаляют свой Brain.

Ваш main будет создавать и заполнять массив Animal, 
половина из которых будет Dog, а другая половина - Cat.

Перед выходом ваш main будет перебирать этот массив и удалять все Animal.
Вы должны удалить Dog и Cat как Animal.
Копия Dog или Cat должна быть «глубокой».
Ваш тест должен показать, что копии глубокие!
Конструкторы и деструкторы каждого класса должны иметь специфический вывод.
Должны быть вызваны соответствующие деструкторы.

int main()
{
    const Animal* j = new Dog();
    const Animal* i = new Cat();
    delete j;//should not create a leak
    delete i;
}

_____________________________________________________________________
Глава IV.

Упражнение 02:  abstract class

_________________________________________________________________
|                        Упражнение: 02                         |
|_______________________________________________________________|
|                  Этот код нечист. ОЧИСТИТЕ ЕГО!               |
|_______________________________________________________________|
|    Каталог сдачи: ex02/                                       |
|_______________________________________________________________|
|   Файлы для передачи: : Makefile, main.cpp, +                 |
|           плюс необходимые файлы для ваших тестов             |
|_______________________________________________________________|
|   Запрещенные функции: нет                                    |
|_______________________________________________________________|

В конце концов, Animal не имеет смысла.
Например, он не издает звука!
Чтобы избежать ошибок в будущем, класс животных по умолчанию не должен 
быть инстанцируемым.
Исправьте класс Animal, чтобы никто не создал его по ошибке.
Остальное должно работать как раньше.
_____________________________________________________________________
Глава V 
Упражнение 03: Интерфейс и резюме

_________________________________________________________________________
|                        Упражнение: 03                                 |
|_______________________________________________________________________|
|                      Интерфейс и резюме                               |
|_______________________________________________________________________|
|   Каталог сдачи: ex03/                                                |
|_______________________________________________________________________|
|   Файлы для передачи: : Makefile, main.cpp, +                         |
|           плюс необходимые файлы для ваших тестов                     |
|_______________________________________________________________________|
|   Запрещенные функции: нет                                            |
|_______________________________________________________________________|

В C ++ 98 (даже в C ++ 20) нет интерфейса, но принято называть чистый 
абстрактный класс интерфейсом. Итак, в этом последнем упражнении давайте 
попробуем интерфейсы и подведем итоги!

Завершите определение следующего класса AMateria и реализуйте необходимые 
функции-члены.

class AMateria
{
    protected:
        [...]
    public:
        AMateria(std::string const & type);
        [...]

        std::string const & getType() const; //Returns the materia type

        virtual AMateria* clone() const = 0;
        virtual void use(ICharacter& target);
};

Создайте конкретную Materias Ice and Cure. Их типом будет их имя в нижнем 
регистре ("ice" for Ice, etc...).
Их метод clone (), конечно же, вернет новый экземпляр настоящего типа Материи.

Что касается метода use(ICharacter&), он будет отображать:
• Ice: "* shoots an ice bolt at NAME *"
• Cure: "* heals NAME’s wounds *"
(Конечно, замените NAME именем Character, заданного в качестве параметра.)

При присвоении Materia другому копировать тип не имеет смысла ...


Создайте класс Character, который будет реализовывать следующий интерфейс:

class ICharacter
{
    public:
        virtual ~ICharacter() {}
        virtual std::string const & getName() const = 0;
        virtual void equip(AMateria* m) = 0;
        virtual void unequip(int idx) = 0;
        virtual void use(int idx, ICharacter& target) = 0;
};

Персонаж обладает инвентарем не более 4 Materia, пустых в начале. 
Он будет использовать Материю в слотах с 0 по 3 в указанном порядке.

Если мы попытаемся оборудовать Materia в полном инвентаре или 
использовать / снять несуществующую Материю, ничего не предпринимайте.

Метод unquip НЕ должен удалять Материю!

Метод use(int, ICharacter &) должен будет использовать Materia в слоте idx 
и передавать target в качестве параметра методу AMateria :: use.

Конечно, вы должны иметь возможность поддерживать ЛЮБУЮ AMateria в инвентаре 
Character.

У вашего Character должен быть конструктор, принимающий его имя в качестве параметра. 
Копирование или присвоение Character, конечно, должно быть глубоким. 
Старая Materia Персонажа должна быть удалена. То же самое при уничтожении Character.


Создайте класс MateriaSource, который должен будет реализовать следующий интерфейс:
class IMateriaSource
{
    public:
        virtual ~IMateriaSource() {}
        virtual void learnMateria(AMateria*) = 0;
        virtual AMateria* createMateria(std::string const & type) = 0;
};

learnMateria должна скопировать Materia, переданную в качестве параметра, и 
сохранить ее в памяти для последующего клонирования. Во многом так же, как и 
в случае с Character, Source может знать не более 4 Материей, 
которые не обязательно уникальны.

createMateria(std::string const &) вернет новую Materia, которая будет 
копией Materia (ранее изученной источником), тип которой равен параметру.
Возвращает 0, если тип неизвестен.

Короче говоря, ваш Source должен уметь изучать «шаблоны» Materia и 
воссоздавать их по запросу. После этого вы сможете создать Materia, 
не зная ее «настоящего» типа, просто идентифицируя ее по строке.


Как обычно, вот основная тестовая программа, которую вам нужно улучшить:

int main()
{
    IMateriaSource* src = new MateriaSource();
    src->learnMateria(new Ice());
    src->learnMateria(new Cure());

    ICharacter* me = new Character("me");

    AMateria* tmp;
    tmp = src->createMateria("ice");
    me->equip(tmp);    
    tmp = src->createMateria("cure");
    me->equip(tmp);

    ICharacter* bob = new Character("bob");

    me->use(0, *bob);
    me->use(1, *bob);

    delete bob;
    delete me;
    delete src;

    return 0;
}

Выход:

$> clang++ -W -Wall -Werror *.cpp
$> ./a.out | cat -e
* shoots an ice bolt at bob *$
* heals bob's wounds *$
